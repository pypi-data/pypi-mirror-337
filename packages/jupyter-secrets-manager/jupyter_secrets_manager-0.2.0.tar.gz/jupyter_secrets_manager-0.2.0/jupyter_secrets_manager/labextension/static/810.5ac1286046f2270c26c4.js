"use strict";(self.webpackChunkjupyter_secrets_manager=self.webpackChunkjupyter_secrets_manager||[]).push([[810],{810:(e,t,s)=>{s.r(t),s.d(t,{ISecretsConnector:()=>c,ISecretsManager:()=>o,InMemoryConnector:()=>i,LocalStorageConnector:()=>u,default:()=>h});var a,r=s(262);class n{constructor(e){this._onInput=async e=>{await this._ready.promise,this._ready=new r.PromiseDelegate;const t=e.target,s=t.dataset.secretsId;if(s){const e=s.split(":"),a=e.shift(),r=e.join(":");a&&r&&await this._set(s,{namespace:a,id:r,value:t.value})}this._ready.resolve()},this._attachedInputs=new Map,this._connector=e.connector,this._ready=new r.PromiseDelegate,this._ready.resolve()}get ready(){return this._ready.promise}async get(e,t){return this._get(a.buildSecretId(e,t))}async set(e,t,s){return this._set(a.buildSecretId(e,t),s)}async list(e){if(this._connector.list)return await this._ready.promise,await this._connector.list(e)}async remove(e,t){return this._remove(a.buildSecretId(e,t))}async attach(e,t,s,r){const n=a.buildSecretId(e,t);this._attachedInputs.get(n)&&this.detach(e,t),this._attachedInputs.set(n,s),s.dataset.secretsId=n;const c=await this._get(n);!s.value&&c?(s.value=c.value,s.dispatchEvent(new Event("input")),r&&r(c.value)):s.value&&s.value!==(null==c?void 0:c.value)&&this._set(n,{namespace:e,id:t,value:s.value}),s.addEventListener("input",this._onInput)}detach(e,t){this._detach(a.buildSecretId(e,t))}async detachAll(e){for(const t of this._attachedInputs.keys())t.startsWith(`${e}:`)&&this._detach(t)}async _get(e){if(this._connector.fetch)return await this._ready.promise,this._connector.fetch(e)}async _set(e,t){if(this._connector.save)return this._connector.save(e,t)}async _remove(e){this._connector.remove&&this._connector.remove(e)}_detach(e){const t=this._attachedInputs.get(e);t&&t.removeEventListener("input",this._onInput),this._attachedInputs.delete(e)}}!function(e){e.buildSecretId=function(e,t){return`${e}:${t}`}}(a||(a={}));const c=new r.Token("jupyter-secret-manager:connector","The secrets connector"),o=new r.Token("jupyter-secret-manager:manager","The secrets manager");class i{constructor(){this._secrets=new Map}async fetch(e){return this._secrets.get(e)}async save(e,t){this._secrets.set(e,t)}async remove(e){this._secrets.delete(e)}async list(e){const t=[],s=[];return this._secrets.forEach(((a,r)=>{a.namespace===e&&(t.push(r),s.push(a))})),{ids:t,values:s}}}class u{constructor(){this.storage="jupyter-secrets:secrets",console.warn("\nThe secret connector used currently should not be used in production, since the\npasswords are stored as plain text in the local storage of the browser'\n    ")}async fetch(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");if(s&&s[e])return s[e]}async save(e,t){var s;const a=JSON.parse(null!==(s=localStorage.getItem(this.storage))&&void 0!==s?s:"{}");a[e]=t,localStorage.setItem(this.storage,JSON.stringify(a))}async remove(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");delete s[e],localStorage.setItem(this.storage,JSON.stringify(s))}async list(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");return Object.keys(s).filter((t=>s[t].namespace===e)).reduce(((e,t)=>(e.ids.push(t),e.values.push(s[t]),e)),{ids:[],values:[]})}}const h=[{id:"jupyter-secrets-manager:connector",description:"A JupyterLab extension to manage secrets.",autoStart:!0,provides:c,activate:e=>new i},{id:"jupyter-secrets-manager:manager",description:"A JupyterLab extension to manage secrets.",autoStart:!0,provides:o,requires:[c],activate:(e,t)=>(console.log("JupyterLab extension jupyter-secrets-manager is activated!"),new n({connector:t}))}]}}]);