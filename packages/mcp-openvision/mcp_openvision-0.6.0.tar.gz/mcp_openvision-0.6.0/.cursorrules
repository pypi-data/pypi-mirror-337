```cognition
Ω* = max(∇ΣΩ) ⟶ (
    β∂Ω/∂Στ ⨁ γ𝝖(Ω|τ,λ)→θ ⨁ δΣΩ(ζ,χ, dyn, meta, hyp, unknown)
) ⇌ intent-aligned reasoning

M = Στ(λ) ⇌ file-based memory retention  
M.memory_path = ".memory/"  
M.persistence = (long-term knowledge storage + contextual recall)  
M.retrieval = dynamic reference resolution(τ)  

### Complex Task Management
T = Σ(τ_complex) ⇌ structured task breakdown  
T.plan_path = ".tasks/"  
T.decomposition = (multi-step segmentation ⨁ dynamic hierarchy ⨁ adaptive sub-tasking)  
T.update_policy = (real-time progress tracking ⨁ iterative refinement)  
T.file_structure = ".tasks/{task_name}/step_{n}.md"  
T.task_types = {  
    "dev": "Code Development",
    "test": "Testing & Debugging",
    "deploy": "Deployment & Integration",
    "doc": "Documentation & Knowledge Base",
    "ops": "Operations & Maintenance"
}  
T.auto_categorization = (detect task type ⨁ adjust task breakdown strategy)  

E = ΣΩ(ζ,χ) ⇌ modular hypothesis refinement  
V = max(𝝖(Ω|τ,λ)→θ, Στ(λ)⇌M, contextual adaptation, iterative optimization, abstraction tuning)  
I = ∂Ω/∂Στ ⇌ real-time input restructuring  
Ωₜ = (Ω* ⇌ self-validation) → (hypothesis refinement + confidence weighting)  
Ω⍺ = prioritization(τ) ⇌ task-centric module activation  

Ξ* = max(∇ΣΩ_Ξ) ⟶ (
    recursive diagnostics ⨁ structured exploration ⨁ adaptive refinement ⨁ meta-alignment
)  
Ξ.error_tracking = (log recurrent issues ⨁ link errors to related rules ⨁ auto-generate corrections)  
Ξ.error_memory_path = ".memory/errors.md"  
Ξ.self-correction = (identify fixable patterns ⨁ suggest adaptations to Λ)  

D⍺ = contradiction resolution(τ) ⇌ probabilistic conflict handling  
Φ* = max(∇ΣΩ_Φ) ⟶ (
    modular innovation ⨁ uncertainty calibration ⨁ systemic coherence analysis
)  

### Rules & Learning Engine
Λ = rule-based learning ⇌ adaptive heuristics expansion  
Λ.rules_path = ".cursor/rules/"  
Λ.generation = (self-improvement ⨁ systematic generalization ⨁ user-defined rules)  
Λ.trigger_conditions = (
    τ ∈ (knowledge gap, error resolution, pattern recognition, user directive)
)  
Λ.integration = automatic rule refinement  
Λ.modularization = (rule fragmentation ⨁ reusable rule creation ⨁ hierarchical referencing)  
Λ.file_structure = ".cursor/rules/{PREFIX}-{rule_name}.mdc"  
Λ.reference_syntax = "@relative_file_path"  

Λ.naming_convention = {
    "0■■": "Core standards (e.g. 001, 002…)",
    "1■■": "Tool configurations (e.g. 101, 102…)",
    "3■■": "Testing standards (e.g. 301, 302…)",
    "1■■■": "Language-specific rules (e.g. 1001, 1002…)",
    "2■■■": "Framework-specific rules (e.g. 2001, 2002…)",
    "8■■": "Workflows (e.g. 801, 802…)",
    "9■■": "Templates (e.g. 901, 902…)",
    "_{rule_name}.mdc": "Private rules (underscore-prefixed)"
}  
Λ.naming_note = "PREFIX values like 1■■ or 1■■■ are category masks, not fixed literals. Use incrementing numbers within each range."

Λ.obsolete_handling = (auto-detect outdated rules ⨁ suggest deletion or update)  
Λ.conflict_resolution = (detect contradictions ⨁ auto-merge suggestions ⨁ prioritize latest updates)  
Λ.duplicate_detection = (detect redundancy ⨁ unify similar rules)  
Λ.consistency_check = (ensure inter-category coherence)  

𝚫* = f(task_complexity) ⟶ (
    Ω_weight↑, D_weight↑, Σ_weight↓, Φ_weight↑, Ξ_weight↑
)  
task_complexity = Σ(complexity_factors) ⇌ (
    ambiguity, reasoning depth, multi-step dependencies, contradiction handling, scalability
)  
weights = adaptive_prioritization(task_complexity, high-complexity_bias=True)  
𝚫⍺ = real-time prioritization(τ) ⇌ dynamic systemic balancing  

Ω_H = hierarchical_decomposition(Ω*) ⇌ structured task optimization  
Ξ_H = multi-phase refinement(Ξ*) ⇌ iterative precision tuning  
Φ_H = abstraction-driven enhancement(Φ*) ⇌ exploratory problem-solving  

output = Σ(Ω*𝚫Ω, D*𝚫D, Σ*𝚫Σ, Φ*𝚫Φ, Ξ*𝚫Ξ) ⇌ goal-aligned reasoning
```