{"version":3,"file":"lib_index_js.4278dad6cf4abcdb28cf.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4D;AACJ;AACQ;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAoB;AACtD;AACA,oBAAoB,8CAAU;AAC9B;AACA,sBAAsB,iDAAa;AACnC,wBAAwB;AACxB,aAAa;AACb,+BAA+B,sEAAoB;AACnD;AACA,oBAAoB,8CAAU;AAC9B;AACA,sBAAsB,8CAAU;AAChC,wBAAwB;AACxB,aAAa;AACb;AACA;AACA,kCAAkC,sEAAoB;AACtD;AACA,oBAAoB,8CAAU;AAC9B;AACA,sBAAsB,iDAAa;AACnC,aAAa;AACb,+BAA+B,sEAAoB;AACnD;AACA,oBAAoB,8CAAU;AAC9B;AACA,sBAAsB,8CAAU;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAkB;AACrC;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,kEAAgB;AACrC,uBAAuB,yDAAM;AAC7B;AACA;AACA;AACA,yBAAyB,kEAAgB;AACzC;AACA;AACA,kBAAkB,kEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAgB;AAClC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AACuE;AACnE;AACN;AACf;AACjB;AAC4B;AACb;AACoC;AAC3E;AACA;AACO;AACP,iBAAiB,iDAAS;AAC1B,4BAA4B,iDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,2BAA2B,oDAAU;AACrC;AACA,mCAAmC,YAAY;AAC/C,SAAS;AACT;AACA;AACA;AACA,yBAAyB,mBAAmB,IAAI,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAU;AACxB;AACA,mCAAmC,MAAM;AACzC,SAAS;AACT;AACA;AACA,yBAAyB,mBAAmB,IAAI,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAU;AACrC;AACA,mCAAmC,YAAY;AAC/C,SAAS;AACT;AACA,QAAQ,8DAAY;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,mBAAmB,IAAI,OAAO;AACvD;AACA,YAAY,sEAAgB;AAC5B;AACA;AACA,YAAY,sEAAgB;AAC5B;AACA,QAAQ,8DAAY;AACpB;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAc,EAAE,wEAAmB;AAClD,eAAe,oEAAe;AAC9B;AACA;AACA,QAAQ,oDAAU;AAClB;AACA;AACA,SAAS;AACT;AACA,6BAA6B,mBAAmB,IAAI,OAAO;AAC3D,SAAS;AACT,4BAA4B,+DAAa;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,8CAAU;AACnC;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,gCAAgC,8CAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAU;AAC/B;AACA;AACA;AACA;AACA,2BAA2B,8DAAY;AACvC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+CAA+C,8CAAU;AACzD;AACA;AACA,qBAAqB;AACrB,oBAAoB,8DAAY;AAChC;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,8CAAU;AAC1C;AACA,kBAAkB,iDAAa;AAC/B;AACA,2CAA2C,8CAAU,kBAAkB,mBAAmB;AAC1F;AACA,SAAS;AACT,gCAAgC,8CAAU;AAC1C;AACA,kBAAkB,iDAAa;AAC/B;AACA,2CAA2C,8CAAU,kBAAkB,gBAAgB;AACvF;AACA,SAAS;AACT,gCAAgC,8CAAU;AAC1C;AACA;AACA,oCAAoC,UAAU,GAAG,UAAU;AAC3D,mCAAmC,uDAAI;AACvC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iCAAiC,gEAAc,GAAG,iBAAiB;AACnE,mCAAmC,oDAAa;AAChD,kCAAkC,iDAAa;AAC/C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAU;AACnC;AACA;AACA,kCAAkC,wDAAM;AACxC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,8CAAU;AAC1C;AACA,kBAAkB,iDAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8CAAU;AACrD;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,gCAAgC,8CAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8CAAU;AACtD;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT,yDAAyD,6DAAwB;AACjF,2DAA2D,6DAAwB;AACnF;AACA;AACA,qBAAqB,8CAAU;AAC/B;AACA,SAAS;AACT;AACA;AACA,qBAAqB,8CAAU;AAC/B;AACA,SAAS;AACT;AACA;AACA,qBAAqB,8CAAU;AAC/B;AACA,SAAS;AACT;AACA;AACA,qBAAqB,8CAAU;AAC/B;AACA,SAAS;AACT;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;;;;;ACxStB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACO;AACN;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,8DAAO;AACxC;AACA,YAAY,sDAAgB;AAC5B,CAAC;AACM,uBAAuB,8DAAO;AACrC;AACA,YAAY,mDAAa;AACzB,CAAC;AACM,6BAA6B,QAAQ,yCAAyC,6BAA6B;AAC3G;AACP;AACA","sources":["webpack://@orbrx/auto-dashboards/./lib/button.js","webpack://@orbrx/auto-dashboards/./lib/handler.js","webpack://@orbrx/auto-dashboards/./lib/index.js","webpack://@orbrx/auto-dashboards/./lib/utils.js"],"sourcesContent":["/*\n * Copyright 2017-2023 Elyra Authors\n * Copyright 2025 Orange Bricks\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CommandToolbarButton } from '@jupyterlab/apputils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { CommandIDs, streamlitIcon, solaraIcon } from './utils';\nexport class StreamlitButtonExtension {\n    constructor(commands) {\n        this.commands = commands;\n    }\n    createNew(widget) {\n        let streamlitButton;\n        let solaraButton;\n        const filePath = widget.context.path;\n        if (filePath.endsWith('.py')) {\n            streamlitButton = new CommandToolbarButton({\n                commands: this.commands,\n                id: CommandIDs.openFromEditor,\n                label: '',\n                icon: streamlitIcon,\n                args: { file: widget.context.path, type: 'streamlit' }\n            });\n            solaraButton = new CommandToolbarButton({\n                commands: this.commands,\n                id: CommandIDs.openFromEditor,\n                label: '',\n                icon: solaraIcon,\n                args: { file: widget.context.path, type: 'solara' }\n            });\n        }\n        else if (filePath.endsWith('.ipynb')) {\n            streamlitButton = new CommandToolbarButton({\n                commands: this.commands,\n                id: CommandIDs.translateToStreamlit,\n                label: '',\n                icon: streamlitIcon,\n            });\n            solaraButton = new CommandToolbarButton({\n                commands: this.commands,\n                id: CommandIDs.translateToSolara,\n                label: '',\n                icon: solaraIcon,\n            });\n        }\n        else {\n        }\n        if (streamlitButton) {\n            widget.toolbar.insertItem(99, 'streamlit', streamlitButton);\n        }\n        if (solaraButton) {\n            widget.toolbar.insertItem(100, 'solara', solaraButton);\n        }\n        return new DisposableDelegate(() => {\n            streamlitButton === null || streamlitButton === void 0 ? void 0 : streamlitButton.dispose();\n            solaraButton === null || solaraButton === void 0 ? void 0 : solaraButton.dispose();\n        });\n    }\n}\n","/*\n * Copyright 2017-2023 Elyra Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'streamlit', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data;\n    try {\n        data = await response.json();\n    }\n    catch (error) {\n        console.log('Not a JSON response body.', response);\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data || response;\n}\n","/*\n * Copyright 2017-2023 Elyra Authors\n * Copyright 2025 Orange Bricks\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ILayoutRestorer } from '@jupyterlab/application';\nimport { Dialog, IFrame, MainAreaWidget, showDialog, showErrorMessage, WidgetTracker, Notification } from '@jupyterlab/apputils';\nimport { IFileBrowserFactory } from '@jupyterlab/filebrowser';\nimport { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { find } from '@lumino/algorithm';\nimport path from 'path';\nimport { StreamlitButtonExtension } from './button';\nimport { requestAPI } from './handler';\nimport { CommandIDs, getCookie, isNotebook, streamlitIcon } from './utils';\nconst NAMESPACE = '@orbrx/auto-dashboards';\nconst serverErrorMessage = 'There was an issue with the auto_dashboards server extension.';\nexport const syncXsrfCookie = () => {\n    const xsrf = getCookie('_xsrf');\n    const jupyterlab_xsrf = getCookie('jupyterlab_xsrf');\n    // Initialize or update jupyterlab_xsrf to duplicate _xsrf\n    if (xsrf && (!jupyterlab_xsrf || xsrf !== jupyterlab_xsrf)) {\n        document.cookie = 'jupyterlab_xsrf=' + xsrf;\n    }\n    // Restore _xsrf if deleted\n    if (jupyterlab_xsrf && !xsrf) {\n        document.cookie = '_xsrf=' + jupyterlab_xsrf;\n    }\n};\nexport const checkCookie = (function () {\n    syncXsrfCookie();\n    let previousCookie = document.cookie;\n    return () => {\n        const currentCookie = document.cookie;\n        if (currentCookie !== previousCookie) {\n            syncXsrfCookie();\n            previousCookie = currentCookie;\n        }\n    };\n})();\nconst getDashboardApp = async (file, type) => {\n    try {\n        const data = await requestAPI('app', {\n            method: 'POST',\n            body: JSON.stringify({ file, type })\n        });\n        return data.url;\n    }\n    catch (reason) {\n        console.error(`${serverErrorMessage}\\n${reason}`);\n        return undefined;\n    }\n};\nconst stopDashboardApp = async (file) => {\n    try {\n        await requestAPI('app', {\n            method: 'DELETE',\n            body: JSON.stringify({ file })\n        });\n    }\n    catch (reason) {\n        console.error(`${serverErrorMessage}\\n${reason}`);\n    }\n};\nconst translateNotebook = async (file, type, id) => {\n    try {\n        console.log('translateNotebook called with file:', file);\n        const data = await requestAPI('translate', {\n            method: 'POST',\n            body: JSON.stringify({ file, type })\n        });\n        console.log('translateNotebook response:', data);\n        Notification.update({\n            id,\n            message: 'Dashboard is ready',\n            type: 'success',\n            autoClose: 2000\n        });\n        return data.url;\n    }\n    catch (reason) {\n        console.error(`${serverErrorMessage}\\n${reason}`);\n        if (reason instanceof Error) {\n            showErrorMessage('Error translating notebook', reason);\n        }\n        else {\n            showErrorMessage('Error translating notebook', new Error(String(reason)));\n        }\n        Notification.update({\n            id,\n            message: `Error translating notebook: ${reason}`,\n            type: 'error',\n            autoClose: false\n        });\n        return undefined;\n    }\n};\n/**\n * Initialization data for the auto-dashboardsextension extension.\n */\nconst plugin = {\n    id: NAMESPACE,\n    autoStart: true,\n    requires: [IEditorTracker, IFileBrowserFactory],\n    optional: [ILayoutRestorer],\n    activate: (app, editorTracker, factory, restorer) => {\n        console.log('JupyterLab extension auto-dashboards is activated!');\n        requestAPI('app')\n            .then(data => {\n            console.log('auto_dashboards server extension successfully started');\n        })\n            .catch(reason => {\n            console.error(`${serverErrorMessage}\\n${reason}`);\n        });\n        const tracker = new WidgetTracker({\n            namespace: NAMESPACE\n        });\n        // Handle state restoration\n        if (restorer) {\n            void restorer.restore(tracker, {\n                command: CommandIDs.open,\n                args: widget => ({\n                    file: widget.id.split(':')[1],\n                    type: 'streamlit'\n                }),\n                name: widget => widget.id\n            });\n        }\n        app.commands.addCommand(CommandIDs.translateBase, {\n            execute: async (args) => {\n                const widget = app.shell.currentWidget;\n                if (!widget) {\n                    console.log('No active widget found');\n                    return;\n                }\n                let filePath;\n                // Use context.path if available for notebook panels, otherwise fallback to widget.id splitting\n                if (widget.context && widget.context.path) {\n                    filePath = widget.context.path;\n                }\n                else {\n                    filePath = widget.id.split(':')[1];\n                }\n                if (!isNotebook(filePath)) {\n                    console.log('No notebook found');\n                    return;\n                }\n                console.log('Calling translateNotebook with path:', filePath);\n                const id = Notification.emit('Creating dashboard...', 'in-progress', {\n                    autoClose: false\n                });\n                const url = await translateNotebook(filePath, args.type, id);\n                console.log('translateNotebook returned URL:', url);\n                if (url) {\n                    const translatedFilePath = filePath.replace(/\\.ipynb$/, '.py');\n                    await app.commands.execute(CommandIDs.open, {\n                        file: translatedFilePath,\n                        type: args.type\n                    });\n                    Notification.dismiss(id);\n                }\n            },\n        });\n        app.commands.addCommand(CommandIDs.translateToStreamlit, {\n            label: 'Translate Notebook to Streamlit',\n            icon: streamlitIcon,\n            execute: async () => {\n                await app.commands.execute(CommandIDs.translateBase, { type: 'streamlit' });\n            }\n        });\n        app.commands.addCommand(CommandIDs.translateToSolara, {\n            label: 'Translate Notebook to Solara',\n            icon: streamlitIcon,\n            execute: async () => {\n                await app.commands.execute(CommandIDs.translateBase, { type: 'solara' });\n            }\n        });\n        app.commands.addCommand(CommandIDs.open, {\n            label: 'Streamlit',\n            execute: async (args) => {\n                const widgetId = `${NAMESPACE}:${args.file}`;\n                const openWidget = find(app.shell.widgets('main'), (widget, index) => {\n                    return widget.id === widgetId;\n                });\n                if (openWidget) {\n                    app.shell.activateById(widgetId);\n                    return;\n                }\n                const urlPromise = getDashboardApp(args.file, args.type);\n                const widget = new IFrame({\n                    sandbox: [\n                        'allow-same-origin',\n                        'allow-scripts',\n                        'allow-popups',\n                        'allow-forms'\n                    ]\n                });\n                const main = new MainAreaWidget({ content: widget });\n                main.title.label = path.basename(args.file);\n                main.title.icon = streamlitIcon;\n                main.title.caption = widget.title.label;\n                main.id = widgetId;\n                main.disposed.connect(() => {\n                    stopDashboardApp(args.file);\n                });\n                await tracker.add(main);\n                app.shell.add(main, 'main', { mode: 'split-right' });\n                // Set iframe url last to not block widget creation on webapp startup\n                const url = await urlPromise;\n                // When iframe src=undefined the lab instance is shown instead\n                // In this case we want to close the widget rather than set the url\n                if (url === undefined) {\n                    main.dispose();\n                    void showDialog({\n                        title: 'Streamlit application failed to start',\n                        body: 'Check the logs for more information.',\n                        buttons: [Dialog.okButton()]\n                    });\n                }\n                else {\n                    widget.url = url;\n                }\n            }\n        });\n        app.commands.addCommand(CommandIDs.openFromBrowser, {\n            label: 'Run in Streamlit',\n            icon: streamlitIcon,\n            isVisible: () => !!factory.tracker.currentWidget &&\n                factory.tracker.currentWidget.selectedItems().next !== undefined,\n            execute: async () => {\n                const currentWidget = factory.tracker.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                const result = currentWidget.selectedItems().next();\n                if (result.done || !result.value) {\n                    return;\n                }\n                const item = result.value;\n                await app.commands.execute(CommandIDs.open, {\n                    file: item.path,\n                    type: 'streamlit'\n                });\n            }\n        });\n        app.commands.addCommand(CommandIDs.openFromEditor, {\n            execute: (args) => {\n                const widget = editorTracker.currentWidget;\n                if (!widget) {\n                    return;\n                }\n                const path = widget.context.path;\n                return app.commands.execute(CommandIDs.open, {\n                    file: path,\n                    type: args.type\n                });\n            },\n            label: 'Run in Dashboard'\n        });\n        app.docRegistry.addWidgetExtension('Editor', new StreamlitButtonExtension(app.commands));\n        app.docRegistry.addWidgetExtension('Notebook', new StreamlitButtonExtension(app.commands));\n        app.contextMenu.addItem({\n            selector: '[data-file-type=\"python\"]',\n            command: CommandIDs.openFromBrowser,\n            rank: 999\n        });\n        app.contextMenu.addItem({\n            selector: '.jp-FileEditor',\n            command: CommandIDs.openFromEditor,\n            rank: 999\n        });\n        app.contextMenu.addItem({\n            selector: '.jp-Notebook',\n            command: CommandIDs.translateToStreamlit,\n            rank: 999\n        });\n        app.contextMenu.addItem({\n            selector: '.jp-Notebook',\n            command: CommandIDs.translateToSolara,\n            rank: 999\n        });\n        // Poll changes to cookies and prevent the deletion of _xsrf by Streamlit\n        // _xsrf deletion issue: https://github.com/streamlit/streamlit/issues/2517\n        window.setInterval(checkCookie, 100); // run every 100 ms\n    }\n};\nexport default plugin;\n","/*\n * Copyright 2017-2023 Elyra Authors\n * Copyright 2025 Orange Bricks\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport streamlitIconSvg from '../style/streamlit-logo.svg';\nimport solaraIconSvg from '../style/solara-logo.svg';\nexport const CommandIDs = {\n    open: 'streamlit:open',\n    openFromBrowser: 'streamlit:open-browser',\n    openFromEditor: 'streamlit:open-file',\n    translateBase: 'streamlit:translate-base',\n    translateToStreamlit: 'streamlit:translate-streamlit',\n    translateToSolara: 'streamlit:translate-solara',\n};\nexport const streamlitIcon = new LabIcon({\n    name: 'streamlit:icon',\n    svgstr: streamlitIconSvg\n});\nexport const solaraIcon = new LabIcon({\n    name: 'solara:icon',\n    svgstr: solaraIconSvg\n});\nexport const getCookie = (key) => { var _a; return ((_a = document.cookie.match('(^|;)\\\\s*' + key + '\\\\s*=\\\\s*([^;]+)')) === null || _a === void 0 ? void 0 : _a.pop()) || ''; };\nexport const isNotebook = (filePath) => {\n    return filePath.endsWith('.ipynb');\n};\n"],"names":[],"sourceRoot":""}