"""
Provide an API for getting information about models. Mainly used by Switch
Electron/Theia/VSCode app.

Info can be retrieved by running `switch <cmd> <args> --json` from
Switch.app. This will launch the bundled switch.py script, which will write the
required info to stdout. But if needed we could create an RPC interface for
switch.py to avoid reloading Python each time. Commands and arguments are shown
below.

`validate arguments` (maybe): check whether there are any arguments in
options.txt that aren't defined in any active module

`validate modules` (maybe): confirm all are available or identify unsound ones. also
minimally reorder modules based on their declared dependencies, to ensure they
will run successfully. Add missing modules based on declared mandatory
dependencies. Identify conflicting modules based on declared conflicts.

`validate inputs` (maybe): check for inconsistencies in data files based on
rules derived from code possibly via documentation framework. check for missing
data needed by current modules. report cases where extra data will be ignored.
report missing optional columns.
"""

import importlib, os, pprint, json

import switch_model
from .utilities import unwrap, _ArgumentParser  # includes some extra actions for Switch

argparser = _ArgumentParser()


def info():
    """
    `info --module-arguments <name>`:
    """

    # parse arguments
    argparser.add_argument(
        "--json",
        default=False,
        action="store_true",
        help="Report results as json text instead of prettified Python objects.",
    )
    argparser.add_argument(
        "--module-list",
        default=False,
        action="store_true",
        help=(
            "report all Switch modules (.py files with define_components "
            "functions inside) found in the Switch search path (given by "
            "`--module-search-path`)"
        ),
    )
    argparser.add_argument(
        "--module-arguments",
        default=None,
        dest="module",
        help=(
            "report all arguments defined by the specified module, including "
            "info about data type, single vs multiple, help text, etc."
        ),
    )
    argparser.add_argument(
        "--scenario-argument-values",
        default=None,
        nargs="?",  # 0 or 1 arg
        const="",  # value used if no name provided (means base scenario)
        dest="arguments_scenario",
        help=(
            "Report current values for all arguments for specified scenario, "
            "parsed from options.txt and/or scenarios.txt. Specify the name of "
            "the scenario after the flag, or pass the flag alone to report on "
            "the base scenario.",
        ),
    )
    options = argparser.parse_args()

    output = []
    # run steps
    if options.module_list:
        output.append(module_list())

    if options.module is not None:
        output.append(module_arguments(options.module))

    if options.arguments_scenario is not None:
        output.append(scenario_argument_values(options.arguments_scenario))

    if len(output) == 1:
        output = output[0]

    # report results in json or plain text
    # print("info requested:")
    if options.json:
        print(json.dumps(output, indent=2))
    else:
        pprint.pprint(output)


def module_list():
    # TODO: sort these based on dependencies (using dependencies var if provided)
    # TODO: remove modules that are masked by modules with the same name earlier
    # in the search path

    # for now, only search in the working directory and switch_model directory
    # TODO: search in user-specified path (--module-search-path) and in site-packages
    # (in case they installed a switch add-on package of some sort)
    # Note: it is a bad idea to test the built-in modules, because that is slow
    # and has weird side effects (e.g., `import this`, some Tk demo code and
    # opening https://xkcd.com/353/ in the system browser)
    # note: the __path__variable of a package is a list, to show all the
    # locations its submodules can be found.

    paths = [(switch_model.__path__, "switch_model."), ([""], "")]
    avail_modules = []
    for path, prefix in paths:
        avail_modules.extend(find_switch_modules(path, prefix))

    return avail_modules


def find_switch_modules(path, prefix):
    """
    pre-cached/pre-sorted wrapper for pkgutil.walk_packages
    """
    if prefix == "switch_model.":
        # return pre-determined list of built-in modules to avoid walking the
        # tree more than necessary. This list can be regenerated by cd'ing
        # to the switch root directory (which puts switch_model into the search
        # path without a prefix), then running switch info --module-list and
        # keeping (and re-sorting) the second set of switch_model.* modules.
        return [
            # standard modules
            "switch_model.timescales",
            "switch_model.financials",
            "switch_model.balancing.load_zones",
            "switch_model.energy_sources.properties",
            "switch_model.generators.core.build",
            "switch_model.generators.core.dispatch",
            "switch_model.reporting",
            # either-or modules
            "switch_model.generators.core.no_commit",
            "switch_model.generators.core.commit.fuel_use",
            "switch_model.generators.core.commit.operate",
            "switch_model.energy_sources.fuel_costs.simple",
            "switch_model.energy_sources.fuel_costs.markets",
            # optional modules (ordering isn't generally important)
            "switch_model.transmission.transport.build",
            "switch_model.transmission.transport.dispatch",
            "switch_model.transmission.copperplate",
            "switch_model.transmission.local_td",
            "switch_model.generators.extensions.storage",
            "switch_model.generators.extensions.hydro_simple",
            "switch_model.generators.extensions.hydro_system",
            "switch_model.generators.core.gen_discrete_build",
            "switch_model.generators.core.commit.discrete",
            "switch_model.balancing.demand_response.simple",
            "switch_model.balancing.demand_response.iterative",
            "switch_model.balancing.demand_response.iterative.r_demand_system",
            "switch_model.balancing.operating_reserves.areas",
            "switch_model.balancing.operating_reserves.spinning_reserves",
            "switch_model.balancing.operating_reserves.spinning_reserves_advanced",
            "switch_model.balancing.planning_reserves",
            "switch_model.energy_sources.fuel_costs.markets_expansion",
            "switch_model.energy_sources.fuel_costs.simple_per_timepoint",
            "switch_model.policies.carbon_policies",
            "switch_model.policies.rps_simple",
            "switch_model.balancing.unserved_load",
            "switch_model.reporting.basic_exports",
            "switch_model.reporting.dump",
            "switch_model.balancing.diagnose_infeasibility",
            "switch_model.hawaii.hydrogen",
            "switch_model.hawaii.ev",
            "switch_model.hawaii.ev_advanced",
            "switch_model.hawaii.rps",
            "switch_model.hawaii.fed_subsidies",
            "switch_model.hawaii.smooth_dispatch",
            "switch_model.hawaii.save_results",
            "switch_model.hawaii.demand_response_simple",
            "switch_model.hawaii.emission_rules",
            "switch_model.hawaii.fuel_markets_expansion",
            "switch_model.hawaii.heco_outlook_2019",
            "switch_model.hawaii.heco_outlook_2020_06",
            "switch_model.hawaii.heco_outlook_2020_08",
            "switch_model.hawaii.heco_plan_2020_06",
            "switch_model.hawaii.heco_plan_2020_08",
            "switch_model.hawaii.hi_spinning_reserves",
            "switch_model.hawaii.lake_wilson",
            "switch_model.hawaii.lng_conversion",
            "switch_model.hawaii.no_central_pv",
            "switch_model.hawaii.no_onshore_wind",
            "switch_model.hawaii.no_renewables",
            "switch_model.hawaii.no_wind",
            "switch_model.hawaii.oahu_plants",
            "switch_model.hawaii.psip_2016_04",
            "switch_model.hawaii.psip_2016_12",
            "switch_model.hawaii.pumped_hydro",
            "switch_model.hawaii.register_hi_storage_reserves",
            "switch_model.hawaii.reserves",
            "switch_model.hawaii.smooth_dispatch_quadratic",
            "switch_model.hawaii.switch_patch",
            "switch_model.hawaii.unserved_load",
        ]
    else:
        # lookup available packages
        import pkgutil

        switch_callbacks = [
            "define_arguments",
            "define_components",
            "define_dynamic_components",
            "load_inputs",
            "pre_solve",
            "pre_iterate",
            "post_iterate",
            "post_solve",
        ]
        avail_modules = []

        for info in pkgutil.walk_packages(path=path, prefix=prefix):
            try:
                mod = importlib.import_module(info.name)
                if any(hasattr(mod, x) for x in switch_callbacks):
                    avail_modules.append(info.name)
            except:
                # some kind of error, skip
                pass
        return avail_modules


def arg_dict(arg, *ops):
    action = arg.__class__.__name__.strip("_")
    if action.endswith("Action"):
        action = action[:-6]
    result = {}
    for flag in arg.option_strings:
        if flag + "s" in arg.option_strings:
            # skip single version of flags when there are duplicate single/plural
            # (e.g., --save-expression and --save-expressions)
            continue
        d = result[flag] = dict()
        d["action"] = action
        for op in ops + ("dest", "nargs", "default", "choices", "help"):
            d[op] = getattr(arg, op)
        # help text may be linewrapped, which Python automatically cleans up
        d["help"] = unwrap(d["help"])
    return result


def module_arguments(module):
    import argparse

    result = dict()

    mod = importlib.import_module(module)

    if hasattr(mod, "define_arguments"):
        mod_parser = _ArgumentParser()
        mod.define_arguments(mod_parser)
        for arg in mod_parser._actions:
            if isinstance(arg, argparse._HelpAction):
                # skip the default --help option
                continue
            else:
                result.update(arg_dict(arg))

    return result


def scenario_argument_values(scenario):
    """
    Parse argument values for specified scenario from options.txt and possibly
    also scenarios.txt.
    """
    import sys
    from . import solve

    if scenario == "":
        # report on base scenario
        args = solve.get_option_file_args()
    else:
        # replicate part of solve_scenarios.scenarios_to_run(), so we don't rely
        # on module-level parsing of the selected scenario and don't checkout
        # the scenario.
        from . import solve_scenarios as ss

        option_file_args = solve.get_option_file_args()
        scenario_manager_args = ss.parser.parse_known_args(args=option_file_args)[0]
        scenario_option_file_args = ss.parser.parse_known_args(args=option_file_args)[1]
        # update global scenario_list_file if needed for get_scenario_dict() (ugh)
        ss.scenario_list_file = scenario_manager_args.scenario_list
        args = scenario_option_file_args + ss.get_scenario_dict()[scenario]

    # Parse arguments as done in switch_model.utilities.SwitchAbstractModel.__init__
    # We replicate the code here in order to do the parsing but skip the
    # logger setup, model construction, etc.
    argparser = _ArgumentParser(allow_abbrev=False)
    for m in solve.get_module_list(args):
        module = importlib.import_module(m)
        if hasattr(module, "define_arguments"):
            module.define_arguments(argparser)
    options = argparser.parse_args(args)
    return vars(options)  # convert to dict
