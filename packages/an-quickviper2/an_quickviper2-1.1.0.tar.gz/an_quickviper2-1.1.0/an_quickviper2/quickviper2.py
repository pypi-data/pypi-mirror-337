# -*- coding: utf-8 -*-
"""QVP2_20250401_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Nef_3Xp9k0z8jV-ezGjHjTQDKn8mP7TJ

# QuickViper2
Condaå®Ÿè¡Œç’°å¢ƒæ¨©é™ä¸è¶³ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€

1. ä»®æƒ³ç’°å¢ƒã®åœ§ç¸®æ›¸åº«ã‚’ä½œæˆ
2. 1.ã§ã§ããŸåœ§ç¸®æ›¸åº«ã‚’æŒ‡å®šãƒ•ã‚©ãƒ«ãƒ€ã«å±•é–‹

ã‚’è¡Œã†ã€‚



```
2025/03/22 0.1.0 å®Œæˆ
2025/03/22 0.1.1 ãƒã‚°ä¿®æ­£
2025/03/23 0.1.3 DebugHelperã¨ã®ä¾å­˜é–¢ä¿‚ä¿®å¾©ã®ãŸã‚
2025/03/23 0.1.6 ãƒã‚°ä¿®æ­£
2025/03/25 0.1.7 ãƒã‚°ä¿®æ­£
2025/03/25 0.1.8 å„ç¨®ä¿®æ­£ã¨æ”¹è‰¯ã€‚UniqueEnvVar ã‚’å°å…¥
2025/03/26 0.2.0 ãƒ–ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒƒãƒ—ã€‚EasyVen, DebugHelper.installerå°å…¥
2025/03/26 0.2.1 conda_unpackä¿®æ­£ã€‚ä»®æƒ³ç’°å¢ƒã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
2025/03/27 0.2.2 compress_venv ãƒã‚°ä¿®æ­£
2025/03/31 1.0.0 ç¬¬ä¸€æ¬¡æ”¹è£… CondaInitializerè¿½åŠ  ä»–
2025/03/31 1.0.1 ãƒŸã‚¹
2025/04/01 1.1.0 pack, extract æ”¹è‰¯ãªã©
```

# QuickViper2

## 1. condacolab èµ·å‹•
### CondaInitializer
- **æ¦‚è¦:** Google Driveæ¥ç¶šã¨ condacolabã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’è¡Œã†
- **ä½¿ç”¨ä¾‹:** ã‚³ãƒ¼ãƒ‰å†’é ­ã«è¨­ç½®ã€‚condacolabã¨å‘¨è¾ºãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒèµ·å‹•ã™ã‚‹ã€‚
"""

# @title a. CondaInitializer å®šç¾© & å®Ÿè¡Œ
from google.colab import drive
drive.mount('/content/drive')
# condacolab èµ·å‹•
get_ipython().system( "pip install -q condacolab" )
import condacolab
get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper


class CondaInitializer:
    def __init__( self ):
        """
        condaã®åˆæœŸè¨­å®šã‚’è¡Œã„ã¾ã™ã€‚
        """
        self.debug = DebugHelper( instance_name = "CondaInitializer")
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()

        # GDriveæ¥ç¶š

        # Colabã§ã¯ "source" ã‚’ä½¿ãˆãªã„ãŸã‚ã€bash -c ã§ conda åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’çµŒç”±ã™ã‚‹
        self.debug.installer_sync( command = [ "bash", "-c", "source", "/usr/local/etc/profile.d/conda.sh" ], shell = True )

        condacolab.install()
        self.debug.installer_sync( "conda install -q mamba -n base -c conda-forge", shell = True )
        self.debug.installer_sync( "conda install -y -q -c conda-forge conda-pack", shell = True )


if __name__ == "__main__":
    condainit = CondaInitializer()

"""## 2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©"""

# @title a. QuickViper2 å®šç¾©
import os
import re
import json
# import yaml
import shutil
import subprocess

from pathlib import Path


get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper
get_ipython().system( "pip install an_UniqueEnvVar" )
from an_uniqueenvvar import UniqueEnvVar


class QuickViper2:
    def __init__( self, venv_name, python_version = "3.10" ):
        from google.colab import drive
        drive.mount( '/content/drive' )

        self.debug = DebugHelper( instance_name = "QuickViper2" )
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()

        self.python_version = python_version

    def create(self, target):
        """
        æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ã« conda ä»®æƒ³ç’°å¢ƒã‚’ä½œæˆã™ã‚‹ã€‚
        args:
            target( str ): ä»®æƒ³ç’°å¢ƒã‚’ä½œæˆã™ã‚‹ãƒ‘ã‚¹
        """
        arg_target = str( target )
        self.debug.log_step(f"Creating conda environment at: { arg_target }", success = None )
        cmd = [
            "conda", "create", "-y", "-q", "-p", arg_target,
            f"python={self.python_version}"
        ]
        # result = subprocess.run(cmd, capture_output=True, text=True)
        result = self.debug.installer_sync( cmd, shell = False )
        if result.returncode != 0:
            raise Exception("Error creating conda environment:")
        else:
            self.debug.log_step("Conda environment created successfully.", success = True )


    def activate( self, target ):
        """
        å±•é–‹ã—ãŸä»®æƒ³ç’°å¢ƒã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã™ã€‚
        args:
            target( str ) : ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
        """
        arg_target = str( target )
        self.debug.log_step( "activate", success = None )
        os.chdir( arg_target )
        result = self.debug.installer( command = f'bash -c "source /usr/local/etc/profile.d/conda.sh && conda activate { arg_target } && exec bash"', shell = True, back = 0 )
        if result.returncode == 0:
           self.debug.log_step(f"ç’°å¢ƒãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ãªã‚Šã¾ã—ãŸã€‚", char="ğŸŒŸ")


    def pack( self, archive, target, destination ):
        """
        conda-pack ã‚’ä½¿ç”¨ã—ã¦ã€ä»®æƒ³ç’°å¢ƒã‚’ tar.gz å½¢å¼ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«åœ§ç¸®ã—ã¾ã™ã€‚
        åœ§ç¸®å¯¾è±¡ã®ç’°å¢ƒãƒ‘ã‚¹ã¯ target, å±•é–‹å…ˆã¯destination,
        ç”Ÿæˆã—ãŸåœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã¯ archive ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚
        return:
            subprocess.CompletedProcess
        """
        self.debug.log_step("åœ§ç¸®å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚", success = None)

        arg_archive = str( archive )
        arg_target = str( target )
        arg_destination = str( destination )
        self.debug.log_step("åœ§ç¸®å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚", success = None)

        # æ—¢å­˜ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãŒã‚ã‚Œã°å‰Šé™¤ã™ã‚‹
        if os.path.exists( arg_archive ):
            self.debug.log_step(f"{ arg_archive } ã«æ—¢å­˜ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãŒå­˜åœ¨ã—ã¾ã™ã€‚å‰Šé™¤ã—ã¾ã™ã€‚", success=None)
            try:
                os.remove( arg_archive )
                self.debug.log_step("æ—¢å­˜ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’æ­£å¸¸ã«å‰Šé™¤ã—ã¾ã—ãŸã€‚", success = True)
            except Exception as e:
                self.debug.log_step(f"æ—¢å­˜ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}", success = False)
                raise

        # conda-pack ã‚³ãƒãƒ³ãƒ‰ã®ä½œæˆ
        cmd = [
            "conda-pack",
            "--prefix", arg_target,
            "--dest-prefix", arg_destination,
            "--format", "tar.gz",
            "--output", arg_archive,
        ]
        self.debug.log_step(f"conda-pack ã‚³ãƒãƒ³ãƒ‰: {' '.join(cmd)}", success=None)

        # ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            # result = self.debug.installer_sync( command = cmd, shell = True )
            self.debug.log_step(f"åœ§ç¸®æˆåŠŸã€‚ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¯ { arg_archive} ã«ä½œæˆã•ã‚Œã¾ã—ãŸã€‚", success=True)
        except subprocess.CalledProcessError as e:
            self.debug.log_step(f"conda-pack ãŒå¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰: {e.returncode}", success=False)
            self.debug.log_step(f"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {e.stderr}", success=False)
            raise
        except Exception as e:
            self.debug.log_step(f"äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}", success=False)
            raise

        self.debug.log_step("åœ§ç¸®å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚", success=True)
        return result


    def extract( self, current, archive, destination ):
        """
        åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’å±•é–‹ã—ã¾ã™ã€‚
        args:
            current( str ): ä»®æƒ³ç’°å¢ƒã®ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            archive( str ): åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            destination( str ): å±•é–‹å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        """
        arg_current = str( current )
        arg_archive = str( archive )
        arg_destination = str( destination )
        self.debug.log_step( "extract", success = None )
        os.chdir( arg_current )
        os.makedirs( arg_destination, exist_ok = True )
        self.debug.installer( command = f"tar -xf { arg_archive } -C { arg_destination }", shell = True, back = 1 )

    # def list_archive( self ):
    #     """
    #     ä»®æƒ³ç’°å¢ƒã®ãƒªã‚¹ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚
    #     """
    #     self.debug.log_step( "list_archive", success = None )
    #     get_ipython().system( f"tar tvf { self.arc_path }" )
    #     self.debug.installer( command = [ "tar", "tvf", str(self.arc_path ) ] )

    def delete_venv( self, target ):
        """
        ä»®æƒ³ç’°å¢ƒã‚’æ¶ˆå»ã—ã¾ã™
        args:
            target( str ): æ¶ˆå»ã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
        """
        self.debug.log_step( "delete_venv", success = None )
        arg_target = str( target )
        if os.path.exists( arg_target ):
            shutil.rmtree( arg_target )


    def set_executable( self, target ):
        """
        å®Ÿè¡Œæ¨©é™ã‚’ä¿®æ­£ã—ã¾ã™ã€‚
        args:
            target( str ): å®Ÿè¡Œæ¨©é™ã‚’ä¿®æ­£ã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
        """
        self.debug.log_step( "set_executable", success = None )
        arg_target = Path( target ).joinpath( "bin" )
        python3_path =  arg_target / "python3.10"
        python_link = arg_target / "python"
        os.chmod(python3_path, 0o755)
        os.chmod(python_link, 0o755)
        self.debug.installer( command = f"ls -l { python3_path }", shell = True)
        self.debug.installer( command = f"ls -l { python_link }", shell = True)


    def set_env_var( self, target ):
        """
        ä½œæˆã—ãŸç’°å¢ƒå†…ã®ç’°å¢ƒå¤‰æ•°ã‚’å®šç¾©ã™ã‚‹ã€‚
        args:
            target( str ): åˆ©ç”¨ã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
        """
        arg_target = str ( Path( target ).joinpath( "bin" ) )
        arg_library = str( Path( target ).joinpath( "lib" ) )
        ue_path = UniqueEnvVar( "PATH" )
        ue_ld_library_path = UniqueEnvVar( "LD_LIBRARY_PATH" )
        ue_path.add_value( arg_target )
        ue_ld_library_path.add_value( arg_library )
        self.debug.log_step( f"PATH : { ue_path.get_values() }" )
        self.debug.log_step( f"LD_LIBRARY_PATH : { ue_ld_library_path.get_values() }" )


    def unlock( self, current, archive, destination, force_unlock = False ):
        """
        åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’å±•é–‹ã—ã¾ã™ã€‚
        args:
            force_unlock( boolean ): Trueã®ã¨ãã€å¼·åˆ¶çš„ã«å±•é–‹ã—ã¾ã™ã€‚
        """
        self.debug.log_step( "unlock", success = None )
        arg_current = str( current )
        arg_archive = str( archive )
        arg_destination = str( destination )
        if force_unlock and Path( arg_destination ).exists():
            shutil.rmtree( arg_destination )
        if not Path( arg_destination ).exists():
            self.extract( current = arg_current, archive = arg_archive, destination = arg_destination )
            # self.conda_unpack()
            self.activate( target = arg_destination )
            self.set_executable( target = arg_destination )
            self.set_env_var( target = arg_destination )

    def executer( self, target, cmdlist = [ "pip", "--version" ] ):
        """
        ä»®æƒ³ç’°å¢ƒã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
        args:
            target( str ): ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ•ã‚©ãƒ«ãƒ€
            cmdlist( str [] ): å®Ÿè¡Œã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³
        """
        self.debug.log_step( "exe_python", success = None )
        arg_target = str( Path( target ).joinpath( "bin" ) )
        os.chdir( arg_target )
        # ç¾åœ¨ã®ç’°å¢ƒå¤‰æ•°ã‚’ã‚³ãƒ”ãƒ¼
        env = os.environ.copy()
        # ã‚·ã‚§ãƒ«ã‚’ä½¿ã£ã¦ "env | grep LD_LIBRARY_PATH" ã‚’å®Ÿè¡Œã—ã€å‡ºåŠ›ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
        # result = subprocess.run(["env"], env=env, capture_output=True, text=True)
        result = subprocess.run("env | grep ^LD_LIBRARY_PATH=", shell=True, env=env, capture_output=True, text=True)
        self.debug.log_step( f"result : { result }", success = None )
        # å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰ã‚’ãƒªã‚¹ãƒˆå½¢å¼ã§å®šç¾©
        cmd = [ str( Path( arg_target ).joinpath( "python" ) ), "-m" ]
        full_cmd = cmd + cmdlist
        self.debug.installer( command = full_cmd )
        ### self.debug.run.commandãŒä½¿ãˆãªã„ç†ç”±ã¯ã‚ã‹ã‚‰ãªã„ã€‚ã“ã‚Œã‚‚ä»®æƒ³ç’°å¢ƒçµ¡ã¿ã‹?
        ### result, stdout, stderr = self.debug.run_command( command = full_cmd, stdout = True, stderr = True )
        ### self.debug.log_step( f"stdout:\n{ stdout }", success = None)
        ### self.debug.log_step( f"stderr:\n{ stdout }", success = None)

# @title b. Mainloop å®šç¾©
class MainLoop():
    def __init__( self, venv_name = "kohya_env" ):
        """
        ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
        """
        self.debug = DebugHelper( instance_name = "MainLoop" )
        self.venv_name = venv_name
        self.even = EasyVen()
        [ self.bch_path,
          self.dst_path,
          self.cur_path,
          self.src_path,
          self.arc_path,
          self.lcl_path,
          self.bin_path,
          self.lib_path,
          self.tmp_path,
          self.org_path ] = self.even.setup( venv_name = self.venv_name )

        self.quickviper = QuickViper2( venv_name = self.venv_name )

    def remove_temp_env(self):
        """
        æ—¢å­˜ã®ç’°å¢ƒãŒã‚ã‚Œã°å‰Šé™¤
        """
        self.quickviper.delete_venv( target = self.tmp_path )


    def create_temp_env(self):
        """
        ä¸€æ™‚çš„ãªç’°å¢ƒã‚’ä½œæˆ
        """
        # ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ç’°å¢ƒã®ä½œæˆã€conda-pack ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã€conda-unpack ã®ç¢ºèªã‚’å®Ÿæ–½
        self.quickviper.create( target = self.tmp_path )

    def pack_temp_env(self):
        """
        ä¸€æ™‚çš„ãªç’°å¢ƒã‚’åœ§ç¸®
        """
        self.quickviper.pack( archive = self.org_path, target = self.tmp_path, destination = self.lcl_path )

    def unpack_temp_env(self):
        """
        ä¸€æ™‚çš„ãªç’°å¢ƒã‚’å±•é–‹
        """
        self.quickviper.unlock( current = self.cur_path, archive = self.org_path, destination = self.lcl_path, force_unlock = True )


    def executer( self ):
        """
        pipã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        """
        self.quickviper.executer( target = self.lcl_path )

"""# 3. ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""

if __name__ == "__main__":
    mainloop = MainLoop()
    mainloop.remove_temp_env()
    mainloop.create_temp_env()
    mainloop.pack_temp_env()
    mainloop.unpack_temp_env()
    mainloop.executer()