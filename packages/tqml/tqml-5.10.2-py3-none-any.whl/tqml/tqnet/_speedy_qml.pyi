import torch.nn as nn
from _typeshed import Incomplete

def timer(f, *args, return_out: bool = False, **kwargs): ...
def tensor_product(matrices): ...
def binary_matrix(n_qubits, device: Incomplete | None = None, dtype=...): ...
def rz_eigenvals(X, n_qubits: Incomplete | None = None, mask: Incomplete | None = None, ones: bool = True): ...
def cnot_perms(n_qubits, wires): ...
def cnot_ring(n_qubits): ...
def cnot_incomplete_ring(n_qubits): ...
def cnot_staircase(up, down, n_qubits): ...
def paulix_perms(n_qubits, wires): ...
def had_small(phi, H: Incomplete | None = None): ...
def had_medium(phi, H: Incomplete | None = None): ...
def had_big(phi): ...
def had(phi, H: Incomplete | None = None): ...
def sqrtZ(phi, conj: bool = False): ...

class CNOT(nn.Module):
    n_qubits: Incomplete
    permutation: Incomplete
    def __init__(self, n_qubits) -> None: ...
    def forward(self, phi): ...

class Hadamard(nn.Module):
    n_qubits: Incomplete
    H: Incomplete
    def __init__(self, n_qubits: Incomplete | None = None) -> None: ...
    def forward(self, phi): ...

class RZ(nn.Module):
    n_qubits: Incomplete
    mask: Incomplete
    def __init__(self, n_qubits) -> None: ...
    def forward(self, phi, thetas): ...

class RX(nn.Module):
    n_qubits: Incomplete
    mask: Incomplete
    H: Incomplete
    def __init__(self, n_qubits) -> None: ...
    def forward(self, phi, thetas): ...

class RY(nn.Module):
    n_qubits: Incomplete
    mask: Incomplete
    sqrtZ: Incomplete
    H: Incomplete
    def __init__(self, n_qubits) -> None: ...
    def forward(self, phi, thetas): ...

class Measurement(nn.Module):
    n_qubits: Incomplete
    observables: Incomplete
    observable: Incomplete
    def __init__(self, n_qubits, observable: str = 'Z_all') -> None: ...
    def forward(self, phi): ...

class StrongEntanglerLayer(nn.Module):
    n_qubits: Incomplete
    RY: Incomplete
    cnot: Incomplete
    mask: Incomplete
    sqrtZ: Incomplete
    H: Incomplete
    def __init__(self, n_qubits, RY: bool = True) -> None: ...
    def forward(self, phi, angles): ...

class StateVector(nn.Module):
    batchsize: Incomplete
    n_qubits: Incomplete
    state: Incomplete
    shape: Incomplete
    cnot_p: Incomplete
    sqrtZ: Incomplete
    bin_mat: Incomplete
    def __init__(self, n_qubits, batchsize: int = 1) -> None: ...
    def set_state(self, state: Incomplete | None = None) -> None: ...
    def hadamard(self) -> None: ...
    def CNOT(self) -> None: ...
    def RZ(self, thetas) -> None: ...
    def RX(self, thetas) -> None: ...
    def RY(self, thetas) -> None: ...
    def measure(self, observable: Incomplete | None = None): ...

def RX2_func(phi, thetas): ...

class RX2(nn.Module):
    n_qubits: Incomplete
    def __init__(self, n_qubits: Incomplete | None = None) -> None: ...
    def forward(self, phi, thetas): ...

def RY2_func(phi, thetas): ...

class RY2(nn.Module):
    n_qubits: Incomplete
    def __init__(self, n_qubits: Incomplete | None = None) -> None: ...
    def forward(self, phi, thetas): ...

def RZ2_func(phi, thetas): ...

class RZ2(nn.Module):
    n_qubits: Incomplete
    def __init__(self, n_qubits: Incomplete | None = None) -> None: ...
    def forward(self, phi, thetas): ...

class StrongEntanglerLayer2(nn.Module):
    n_qubits: Incomplete
    RY: Incomplete
    cnot: Incomplete
    H: Incomplete
    def __init__(self, n_qubits, RY: bool = True) -> None: ...
    def forward(self, phi, angles): ...
