# generated by datamodel-codegen:
#   filename:  data_room.json

from __future__ import annotations

from typing import Optional, Sequence, Union

from typing_extensions import Literal, NotRequired, TypedDict


class AudienceReference1(TypedDict):
    kind: Literal['BASE']


class AudienceReference2(TypedDict):
    id: str
    kind: Literal['CUSTOM']


class AudienceReference3(TypedDict):
    audienceType: str
    kind: Literal['SEED']


AudienceReference = Union[AudienceReference1, AudienceReference2, AudienceReference3]


BooleanOp = Literal['AND', 'OR']


CombineOperator = Literal['INTERSECT', 'UNION', 'DIFF']


class CustomAudienceDefinition1(TypedDict):
    excludeSeedAudience: NotRequired[Optional[bool]]
    kind: Literal['LOOKALIKE']
    reach: int
    sourceRef: AudienceReference


FilterOperator = Literal[
    'CONTAINS_ANY_OF', 'CONTAINS_NONE_OF', 'CONTAINS_ALL_OF', 'EMPTY', 'NOT_EMPTY'
]


FormatType = Literal[
    'STRING',
    'INTEGER',
    'FLOAT',
    'EMAIL',
    'DATE_ISO8601',
    'PHONE_NUMBER_E164',
    'HASH_SHA256_HEX',
]


HashingAlgorithm = Literal['SHA256_HEX']


ModelEvaluationType = Literal['ROC_CURVE', 'DISTANCE_TO_EMBEDDING', 'JACCARD']


Permission = Literal[
    'VIEW_OVERLAP',
    'VIEW_INSIGHTS',
    'PROVIDE_SEED_AUDIENCE',
    'PROVIDE_BASE_AUDIENCE',
    'CREATE_CUSTOM_AUDIENCE',
    'EXPORT_AUDIENCE',
    'MODEL_QUALITY',
]


class AudienceFilter(TypedDict):
    attribute: str
    operator: FilterOperator
    values: NotRequired[Sequence[str]]


class AudienceFilters(TypedDict):
    booleanOp: BooleanOp
    filters: Sequence[AudienceFilter]


class ModelEvaluationConfig(TypedDict):
    postScopeMerge: Sequence[ModelEvaluationType]
    preScopeMerge: Sequence[ModelEvaluationType]


class ParticipantGroup(TypedDict):
    emails: Sequence[str]
    organizationId: NotRequired[Optional[str]]
    permissions: Sequence[Permission]
    role: str


class AudienceCombinator(TypedDict):
    filters: NotRequired[Optional[AudienceFilters]]
    operator: CombineOperator
    sourceRef: AudienceReference


class CustomAudienceDefinition2(TypedDict):
    combine: NotRequired[Sequence[AudienceCombinator]]
    filters: NotRequired[Optional[AudienceFilters]]
    kind: Literal['RULE_BASED']
    sourceRef: AudienceReference


CustomAudienceDefinition = Union[CustomAudienceDefinition1, CustomAudienceDefinition2]


class CustomAudience(TypedDict):
    createdAt: str
    createdBy: str
    definition: CustomAudienceDefinition
    doesAudienceDependOnLookalikeAudience: NotRequired[bool]
    id: str
    isStale: NotRequired[bool]
    name: str
    sharedWith: NotRequired[Sequence[str]]


class MediaDcr1(TypedDict):
    audiencesPolicyId: NotRequired[Optional[str]]
    audiencesPolicyProvisionedAt: NotRequired[Optional[str]]
    customAudiences: Sequence[CustomAudience]
    demographicsPolicyId: NotRequired[Optional[str]]
    embeddingsPolicyId: NotRequired[Optional[str]]
    features: Sequence[str]
    hashMatchingIdWith: NotRequired[Optional[HashingAlgorithm]]
    matchingIdFormat: FormatType
    matchingPolicyId: NotRequired[Optional[str]]
    modelEvaluation: NotRequired[Optional[ModelEvaluationConfig]]
    name: str
    participantGroups: Sequence[ParticipantGroup]
    segmentsPolicyId: NotRequired[Optional[str]]
    version: Literal['v0']


MediaDcr = MediaDcr1


class DataRoom1(TypedDict):
    media: MediaDcr


DataRoom = DataRoom1
