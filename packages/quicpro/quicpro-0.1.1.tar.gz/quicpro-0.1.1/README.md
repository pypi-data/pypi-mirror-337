# Quicpro

A production-ready, synchronous pipeline library for sending messages through multiple protocol layers:
- Encoding/decoding
- HTTP/3 stream mapping
- QUIC packet packaging
- TLS encryption/decryption
- UDP transmission

This library is structured with single-responsibility components, allowing you to easily integrate robust protocol implementations into your production system.

## Usage Examples

```python
import os
import json
import binascii
from quicpro.client import Client
from quicpro.src.sender.tls_encryptor import TLSConfig

def load_tls_config():
    """
    Load TLS configuration from a file (tls_config.json) that contains hex-encoded
    values for "key" and "iv". This file should be generated by your deploy script.
    """
    config_path = "tls_config.json"
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"TLS configuration file not found: {config_path}")

    with open(config_path, "r") as f:
        config = json.load(f)

    key = binascii.unhexlify(config["key"])
    iv  = binascii.unhexlify(config["iv"])
    
    
    return TLSConfig(key=key, iv=iv)

def main():
    # Load secure TLS configuration from file.
    tls_config = load_tls_config()

    # Instantiate the Client using your production endpoint.
    # Here, production runs on localhost port 5099.
    client = Client(remote_address=("127.0.0.1", 5099), timeout=20.0)

    # Override the client's TLS configuration with secure values.
    client.tls_encryptor.config = tls_config
    client.tls_decryptor.config = tls_config

    # Send a request to your production endpoint.
    print("Sending request to http://localhost:5099 ...")
    response = client.request("GET", "http://localhost:5099")
    print("Response:", response)

    # Cleanly close the client.
    client.close()

if __name__ == "__main__":
    main()
```

**use the deploy.sh to create the tls_config.json**


## General Description

The example usage demonstrates how to build both sender and receiver pipelines. The receiver continuously listens for UDP packets, decrypts and processes them through the protocol layers, and finally delivers a decoded message to the consumer application. Meanwhile, the sender builds a corresponding pipeline to encode and encrypt messages, which are then transmitted over UDP to the receiver.