import pulp as plp
from numpy.typing import NDArray

from mapc_optimal.utils import OptimizationType


class Main:
    r"""
    The main problem responsible for the selection and time division of configurations
    generated by the pricing problem.
    """

    def __init__(
            self,
            log_approx: tuple[NDArray, NDArray],
            opt_type: OptimizationType,
            solver: plp.LpSolver,
            M: float
    ) -> None:
        r"""
        Parameters
        ----------
        log_approx : tuple[NDArray, NDArray]
            Tuple containing the slopes and biases of the piecewise linear approximation of the logarithm function.
        opt_type : OptimizationType
            The type of optimization problem to solve.
        solver : pulp.LpSolver
            The solver used to solve the optimization problem.
        M : float
            The value of the big-M parameter.
        """

        self.log_approx = log_approx
        self.opt_type = opt_type
        self.solver = solver
        self.M = M

    def __call__(
            self,
            stations: list,
            link_node_b: dict,
            conf_links: dict,
            conf_link_rates: dict,
            conf_total_rates: dict,
            confs: list,
            baseline: dict
    ) -> tuple[dict, float]:
        """
        Solves the main problem given the configurations generated by the pricing problem.
        Returns the dual variables, the shares of the configurations and the value of the objective function.

        Parameters
        ----------
        stations : list
            List of the station nodes.
        link_node_b : dict
            Dictionary containing the mapping of links to the station nodes.
        conf_links : dict
            Dictionary containing the links of each configuration.
        conf_link_rates : dict
            Dictionary containing the rates of each link for each configuration.
        conf_total_rates : dict
            Dictionary containing the total rate of each configuration.
        confs : list
            List of the configurations.
        baseline : dict
            Dictionary containing the baseline rates of the links.

        Returns
        -------
        result : tuple[dict, float]
            Tuple containing the results of the optimization problem and the value of the objective function.
        """

        main = plp.LpProblem('main', plp.LpMaximize)

        conf_weight = plp.LpVariable.dicts('conf_weight', confs, lowBound=0, upBound=1, cat=plp.LpContinuous)
        node_throughput = plp.LpVariable.dicts('node_throughput', stations, lowBound=0, cat=plp.LpContinuous)
        min_throughput = plp.LpVariable('min_throughput', lowBound=0, cat=plp.LpContinuous)
        log_approx = plp.LpVariable.dicts('log_approx', stations, cat=plp.LpContinuous)
        y = plp.LpVariable('y', lowBound=0, cat=plp.LpContinuous)

        # fraction of time when we use the configuration, the sum of all the weights is 1
        main += plp.lpSum(conf_weight[c] for c in confs) == 1, 'conf_weight_c'  # dual: alpha

        for s in stations:
            # calculation of the summarized throughput of each station (over all the used configurations)
            main += node_throughput[s] == plp.lpSum(
                conf_link_rates[c][l] * conf_weight[c] for c in confs for l in conf_links[c] if link_node_b[l] == s
            ), f'node_throughput_{s}_c'  # dual: beta

            # calculation of the worst throughput (this constraint is especially necessary for max-min optimization)
            main += node_throughput[s] >= min_throughput, f'worst_throughput_{s}_c'

            if self.opt_type == OptimizationType.PROPORTIONAL:
                # approximation of the logarithm function
                for k, (a, b) in enumerate(zip(*self.log_approx)):
                    main += log_approx[s] <= a * node_throughput[s] + b, f'log_approx_{s}_{k}_c'  # dual: beta (proportional)
            elif self.opt_type == OptimizationType.MAX_MIN_BASELINE:
                # enforcement of the baseline rates
                main += node_throughput[s] >= baseline[s] - y, f'baseline_{s}_c'  # dual: gamma

        if self.opt_type == OptimizationType.SUM:
            # maximization of the total throughput
            main += plp.lpSum(conf_total_rates[c] * conf_weight[c] for c in confs), 'total_throughput_g'
        elif self.opt_type == OptimizationType.MAX_MIN:
            # maximization of the worst throughput
            main += min_throughput, 'min_throughput_g'
        elif self.opt_type == OptimizationType.MAX_MIN_BASELINE:
            # maximization of the worst throughput with enforcement of the baseline rates
            main += min_throughput - self.M * y, 'min_throughput_baseline_g'
        elif self.opt_type == OptimizationType.PROPORTIONAL:
            # maximization of the sum of the logarithms of the throughputs
            main += plp.lpSum(log_approx[s] for s in stations), 'log_throughput_g'
        else:
            raise ValueError('Invalid optimization type')

        main.conf_weight = conf_weight

        main.solve(self.solver)

        if main.status != plp.LpStatusOptimal:
            raise Exception('Main problem not solved optimally')

        beta_dual = {s: main.constraints[f'node_throughput_{s}_c'].pi for s in stations}
        gamma_dual = {}

        if self.opt_type == OptimizationType.PROPORTIONAL:
            beta_dual = {(s, k): main.constraints[f'log_approx_{s}_{k}_c'].pi for s in stations for k in range(len(self.log_approx[0]))}
        elif self.opt_type == OptimizationType.MAX_MIN_BASELINE:
            gamma_dual = {s: main.constraints[f'baseline_{s}_c'].pi for s in stations}

        result = {
            'alpha': main.constraints['conf_weight_c'].pi,
            'beta': beta_dual,
            'gamma': gamma_dual,
            'shares': {c: main.conf_weight[c].varValue for c in confs}
        }

        return result, plp.value(main.objective)
